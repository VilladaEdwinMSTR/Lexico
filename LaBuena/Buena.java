/* Buena.java */
/* Generated By:JavaCC: Do not edit this line. Buena.java */
import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class Buena implements BuenaConstants {
    static List<String> lista = new ArrayList<String>();
    public static void main(String[] args) throws ParseException
    {
        try
        {
            Buena parser = new Buena(System.in);
            parser.Inicio();
        }
        catch (ParseException e)
        {
            System.out.println("Error de compilaci\u00f3n: " + e.getMessage());
        }
    }

  static final public void Inicio() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OperadoresAritmeticos:{
        jj_consume_token(OperadoresAritmeticos);
        break;
        }
      case OperadoresLogicos:{
        jj_consume_token(OperadoresLogicos);
        break;
        }
      case ComparacionLogica:{
        jj_consume_token(ComparacionLogica);
        break;
        }
      case FuncionesMatematicas:{
        jj_consume_token(FuncionesMatematicas);
        break;
        }
      case Proteccion:{
        jj_consume_token(Proteccion);
        break;
        }
      case Asignacion:{
        jj_consume_token(Asignacion);
        break;
        }
      case AsignacionBit:{
        jj_consume_token(AsignacionBit);
        break;
        }
      case AsignacionDesplazamientoBit:{
        jj_consume_token(AsignacionDesplazamientoBit);
        break;
        }
      case ParIzquierdo:{
        jj_consume_token(ParIzquierdo);
        break;
        }
      case ParDerecho:{
        jj_consume_token(ParDerecho);
        break;
        }
      case LlaveIzq:{
        jj_consume_token(LlaveIzq);
        break;
        }
      case LlaveDer:{
        jj_consume_token(LlaveDer);
        break;
        }
      case CorcheteDer:{
        jj_consume_token(CorcheteDer);
        break;
        }
      case CorcheteIzq:{
        jj_consume_token(CorcheteIzq);
        break;
        }
      case TiposdeDatos:{
        jj_consume_token(TiposdeDatos);
        break;
        }
      case Ciclos:{
        jj_consume_token(Ciclos);
        break;
        }
      case Excepciones:{
        jj_consume_token(Excepciones);
        break;
        }
      case Pregunta:{
        jj_consume_token(Pregunta);
        break;
        }
      case Consecuencia:{
        jj_consume_token(Consecuencia);
        break;
        }
      case AgregaElemento:{
        jj_consume_token(AgregaElemento);
        break;
        }
      case Combina:{
        jj_consume_token(Combina);
        break;
        }
      case MueveElemento:{
        jj_consume_token(MueveElemento);
        break;
        }
      case AgregaBorraElemento:{
        jj_consume_token(AgregaBorraElemento);
        break;
        }
      case PreguntaCondicion:{
        jj_consume_token(PreguntaCondicion);
        break;
        }
      case EliminaElemento:{
        jj_consume_token(EliminaElemento);
        break;
        }
      case Inspecciona:{
        jj_consume_token(Inspecciona);
        break;
        }
      case Modifica:{
        jj_consume_token(Modifica);
        break;
        }
      case Iteradores:{
        jj_consume_token(Iteradores);
        break;
        }
      case Volatil:{
        jj_consume_token(Volatil);
        break;
        }
      case Mutable:{
        jj_consume_token(Mutable);
        break;
        }
      case Treat:{
        jj_consume_token(Treat);
        break;
        }
      case Registrar:{
        jj_consume_token(Registrar);
        break;
        }
      case Automatico:{
        jj_consume_token(Automatico);
        break;
        }
      case Constante:{
        jj_consume_token(Constante);
        break;
        }
      case VariableLet:{
        jj_consume_token(VariableLet);
        break;
        }
      case VariableGlobal:{
        jj_consume_token(VariableGlobal);
        break;
        }
      case ReduceSobrecarga:{
        jj_consume_token(ReduceSobrecarga);
        break;
        }
      case EvaluaComp:{
        jj_consume_token(EvaluaComp);
        break;
        }
      case EvitaConv:{
        jj_consume_token(EvitaConv);
        break;
        }
      case NoExcepcion:{
        jj_consume_token(NoExcepcion);
        break;
        }
      case Sobrecarga:{
        jj_consume_token(Sobrecarga);
        break;
        }
      case Operador:{
        jj_consume_token(Operador);
        break;
        }
      case Referencia:{
        jj_consume_token(Referencia);
        break;
        }
      case GestionTipos:{
        jj_consume_token(GestionTipos);
        break;
        }
      case DefineEstruct:{
        jj_consume_token(DefineEstruct);
        break;
        }
      case ControlFlujo:{
        jj_consume_token(ControlFlujo);
        break;
        }
      case Salta:{
        jj_consume_token(Salta);
        break;
        }
      case DevuelveGuarda:{
        jj_consume_token(DevuelveGuarda);
        break;
        }
      case Alineacion:{
        jj_consume_token(Alineacion);
        break;
        }
      case Asercion:{
        jj_consume_token(Asercion);
        break;
        }
      case GestionMemoria:{
        jj_consume_token(GestionMemoria);
        break;
        }
      case GestionTiposCasting:{
        jj_consume_token(GestionTiposCasting);
        break;
        }
      case ManejoExcepciones:{
        jj_consume_token(ManejoExcepciones);
        break;
        }
      case EjecutaBloque:{
        jj_consume_token(EjecutaBloque);
        break;
        }
      case MetodosFile:{
        jj_consume_token(MetodosFile);
        break;
        }
      case ManejoRutas:{
        jj_consume_token(ManejoRutas);
        break;
        }
      case InstanciasFile:{
        jj_consume_token(InstanciasFile);
        break;
        }
      case MetodosTime:{
        jj_consume_token(MetodosTime);
        break;
        }
      case InstanciasTime:{
        jj_consume_token(InstanciasTime);
        break;
        }
      case Valores:{
        jj_consume_token(Valores);
        break;
        }
      case Separador:{
        jj_consume_token(Separador);
        break;
        }
      case MarcadorFinal:{
        jj_consume_token(MarcadorFinal);
        break;
        }
      case Escribe:{
        jj_consume_token(Escribe);
        break;
        }
      case Lee:{
        jj_consume_token(Lee);
        break;
        }
      case MetodoEstatico:{
        jj_consume_token(MetodoEstatico);
        break;
        }
      case MetodoVoid:{
        jj_consume_token(MetodoVoid);
        break;
        }
      case MetodoMain:{
        jj_consume_token(MetodoMain);
        break;
        }
      case AlteraTexto:{
        jj_consume_token(AlteraTexto);
        break;
        }
      case Aleatorio:{
        jj_consume_token(Aleatorio);
        break;
        }
      case Clase:{
        jj_consume_token(Clase);
        break;
        }
      case Paquete:{
        jj_consume_token(Paquete);
        break;
        }
      case Argumentos:{
        jj_consume_token(Argumentos);
        break;
        }
      case Visible:{
        jj_consume_token(Visible);
        break;
        }
      case tamVentana:{
        jj_consume_token(tamVentana);
        break;
        }
      case Estructura:{
        jj_consume_token(Estructura);
        break;
        }
      case Inter:{
        jj_consume_token(Inter);
        break;
        }
      case IDENTIFICADOR:{
        jj_consume_token(IDENTIFICADOR);
        break;
        }
      case Procedimiento:{
        jj_consume_token(Procedimiento);
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OperadoresAritmeticos:
      case OperadoresLogicos:
      case ComparacionLogica:
      case AlteraTexto:
      case Aleatorio:
      case Valores:
      case Separador:
      case MarcadorFinal:
      case Escribe:
      case Lee:
      case Procedimiento:
      case FuncionesMatematicas:
      case Visible:
      case tamVentana:
      case Estructura:
      case Proteccion:
      case Asignacion:
      case AsignacionBit:
      case AsignacionDesplazamientoBit:
      case ParIzquierdo:
      case ParDerecho:
      case LlaveIzq:
      case LlaveDer:
      case CorcheteDer:
      case CorcheteIzq:
      case Ciclos:
      case Pregunta:
      case PreguntaCondicion:
      case Consecuencia:
      case AgregaElemento:
      case Combina:
      case MueveElemento:
      case AgregaBorraElemento:
      case EliminaElemento:
      case Inspecciona:
      case Modifica:
      case Iteradores:
      case Volatil:
      case Mutable:
      case Treat:
      case Registrar:
      case Automatico:
      case Constante:
      case VariableLet:
      case VariableGlobal:
      case ReduceSobrecarga:
      case EvaluaComp:
      case EvitaConv:
      case NoExcepcion:
      case Sobrecarga:
      case Operador:
      case Referencia:
      case GestionTipos:
      case DefineEstruct:
      case ControlFlujo:
      case Salta:
      case DevuelveGuarda:
      case Alineacion:
      case Asercion:
      case GestionMemoria:
      case GestionTiposCasting:
      case ManejoExcepciones:
      case EjecutaBloque:
      case MetodosFile:
      case Excepciones:
      case ManejoRutas:
      case InstanciasFile:
      case MetodosTime:
      case InstanciasTime:
      case TiposdeDatos:
      case MetodoEstatico:
      case MetodoVoid:
      case MetodoMain:
      case Clase:
      case Paquete:
      case Argumentos:
      case Inter:
      case IDENTIFICADOR:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public BuenaTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[2];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xffffffc0,0xffffffc0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xffffffff,0xffffffff,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xfffff,0xfffff,};
   }

  /** Constructor with InputStream. */
  public Buena(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Buena(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new BuenaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Buena(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new BuenaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Buena(BuenaTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(BuenaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[84];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 2; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 84; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
